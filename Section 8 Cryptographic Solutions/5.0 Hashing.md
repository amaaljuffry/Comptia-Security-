
#### **1. Core Concept of Hashing**
*   **Purpose:** Provides **integrity** in network security.
*   **Definition:** A **one-way cryptographic function** that takes an input (any size) and produces a fixed-length, unique output called a **message digest** or **hash digest**.
*   **Key Properties:**
    *   **One-Way Function:** It is computationally infeasible to reverse the process and determine the original input from the hash digest.
    *   **Digital Fingerprint:** The hash digest acts as a unique identifier for the original file/message.
    *   **Fixed Length:** The output hash is always the same length, regardless of the input size (e.g., a one-word file and a million-word file will produce hashes of the same length for a given algorithm).

---

#### **2. Common Hashing Algorithms**

| Algorithm | Family | Key Features | Hash Lengths | Notes |
| :--- | :--- | :--- | :--- | :--- |
| **MD5** | N/A | - Most popular for decades.<br>- **128-bit** hash value.<br>- Prone to **collisions** (different inputs producing the same hash). | 128-bit | Considered weak and deprecated for secure applications due to its limited output space and high collision probability. |
| **SHA** (Secure Hash Algorithm) | SHA-1 | - Creates a **160-bit** hash digest.<br>- Reduces collisions compared to MD5. | 160-bit | Now considered insecure and being phased out. |
| | **SHA-2** | - A family of stronger algorithms.<br>- Named after their digest length. | 224, 256, 384, 512-bit | **SHA-256** and **SHA-512** are currently very common and secure. Uses 64-80 rounds of computation. |
| | **SHA-3** | - Newer family with a different internal structure.<br>- Major increase in security. | 224, 256, 384, 512-bit | Uses **120 rounds of computation**, making it more secure than SHA-2. |
| **RIPEMD** (RACE Integrity Primitive Evaluation Message Digest) | N/A | - Open-source competitor to SHA.<br>- Less popular than SHA. | 160, 256, 320-bit | The **RIPEMD-160** version is the most commonly used. |
| **HMAC** (Hash-based Message Authentication Code) | N/A | - Used for message **integrity** and **authenticity**.<br>- **Pairs with other hash algorithms** (e.g., HMAC-MD5, HMAC-SHA256).<br>- Uses a shared secret key. | Varies | Provides a way to ensure a message came from the correct sender and wasn't altered. |

#### **3. Digital Signatures (Application of Hashing)**
*   **Purpose:** Ensures **integrity**, **authenticity**, and provides **non-repudiation**.
*   **How it's Created:**
    1.  The original file/message is passed through a hashing algorithm (e.g., SHA-256) to generate a hash digest.
    2.  This hash digest is **encrypted using the sender's private key**.
    3.  The resulting encrypted hash is the **digital signature**, which is attached to the message.
*   **How it's Verified:**
    1.  The receiver decrypts the digital signature using the **sender's public key** to reveal the original hash digest.
    2.  The receiver independently hashes the received message using the same algorithm.
    3.  The two hashes are compared:
        *   **If they match:** The message is intact (integrity) and was sent by the claimed sender (authenticity & non-repudiation).

*   **Non-Repudiation:** The sender cannot deny sending the message because only they possess the private key used to create the valid signature.

*   **Common Algorithms for Digital Signatures:**
    *   **DSA (Digital Signature Algorithm):** Used in the government's DSS (Digital Security Standard).
    *   **RSA (Rivest-Shamir-Adleman):** More common in commercial use; can also be used for encryption and key distribution.
    *   **ECC (Elliptic Curve Cryptography):** An efficient version that can be used with DSA or SHA.

---

#### **4. Code Signing (Another Application)**
*   **Purpose:** Verifies that software (apps, installers) has not been modified since it was published by the developer.
*   **Process:** Identical to digital signatures. The developer hashes the application file and encrypts the hash with their private key. The app store or user's system can verify this signature using the developer's public key.

---

#### **5. Key Demonstration: The Avalanche Effect**
(MD5 Hash Generator)
*   **Concept:** A tiny change in the input (even a single character, bit, or space) results in a **drastically different** hash output.
*   **Why this matters:** This property makes hashing extremely sensitive to modifications, which is essential for verifying integrity. If the hashes match, the files are absolutely identical.

---

#### **6. Key Terms & Definitions**
*   **Collision:** When two different input files produce the **same hash digest**. This is a weakness, and modern algorithms (like SHA-256) are designed to minimize this risk.
*   **Integrity:** Assurance that data has not been altered.
*   **Authenticity:** Assurance that data comes from the claimed source.
*   **Non-Repudiation:** The inability for a sender to deny having sent a message.

---

### **Summary & Key Takeaways**
1.  **Hashing is a one-way function** for creating a unique, fixed-size digital fingerprint (message digest) of data.
2.  It is primarily used to **verify integrity**.
3.  **MD5 is weak**; modern systems should use **SHA-256** or **SHA-3**.
4.  **Digital Signatures** combine hashing with asymmetric encryption to provide integrity, authenticity, and non-repudiation.
5.  **Code Signing** is a practical use of digital signatures for software distribution.
6.  The **Avalanche Effect** ensures that any change in the input creates a completely different hash, making it easy to detect tampering.